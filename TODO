implicit type conversions in 'store', test type conversions
binary operations (coercions of return value for scalar + array)
ranges (rolling, lazy rolling)
tensor indices to enable transpose of lazy array
test lazyness
lazy ranges
sums/injections? nesting? tensors?
JIT?

values: Malloc, List, Ruby, JIT-variable?

a = lazy( 16 ) { |i| i }
a = lazy( 16 ) { |i| i }[ 4 ... 12 ]  # offsets: apply sel-operation to all
                                        members; index array?
a = lazy( 16, 32 ) { |i,j| Sequence[ i, j ] } # ???
a = lazy( 8, 8 ) { |i,j| Sequence[ i, a[j] * sin( i + b[j] ) ] }.hist 8, 8
a = b.class.new.op { |x| set -x }
a = lazy { |i| -b[i] }
a = lazy { -b }
a = array { -b }
a = array { |i| -b[i] }
a = array( :dim => [ b.size ] ) { |i| -b[i] }
a = -b
array { |i| sum { |j| a[i,j] } }
lazy { |i| sum { |j| a[i,j] } }
lazy { |i| lazy { |j| a[i,j] } }
array { lazy { |i| sum { |j| a[i,j] } } }

correlate?

lines:
[ i, a[j] * sin( i + b[j] ) ].hist

lines:
lazy { |i,j| i.zip( a[j] * sin( i + b[j] ) ) }.histogram 32, 20

lines:
lazy { |i,j| Sequence[ i, a[j] * sin( i + b[j] ) ] }.histogram 32, 20
combined histograms?

circle:
[ sin( i ) * r, cos( i ) * r ].hist

Geometric Hashing? Bounded Hough Transform!!! RANSAC? histogram weights?

array: lazy retrieval? jit code for address computation
OBJECT: object with type information
Lazy( Sequence( INT, 3 ) )

interpretation: type coercion, actual operation, jit,
collection of jit arguments (e.g. tensor)

storage: handled by aggregated member (memory,array,lazy)
operations: handled by thread-global interpreter (jit,ruby,parallel)

proc { |i| proc { |j| i+j } }.call( 5 ).call 3

also see rubyconf prototype code

gem install flay: http://ruby.sadi.st/Flay.html

How to nest mode-environments?
How to cascade delegates?
(how to specify nested modes for recursive algorithms and called algorithms?)
ruby and jit compiles, lazy and parallel forwards

* Ruby
* Lazy (Lazy histogram -> hough transform, lazy transpose, unused indices?)
* Multithreading
* JIT
* GCC
