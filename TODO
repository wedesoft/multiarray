# Documentation: List
# histogram (implement using injection)
# pointer-increments for better efficiency, optimize Node#diagonal
# random numbers
# Geometric Hashing? Bounded Hough Transform!!! RANSAC? histogram weights?
# each, multi_each, collect, multi_collect, zip?
# inject: n-d masks for warp
# block(var1,var2,...) with smart subst?

# downsampling after correlation?
# YARD documentation with pictures, demo video, @group ..., @endgroup
# CK_Thesis.pdf: tensor voting
# maxint -> native_int

# f(g(i)) # g(i), f(g(i)) all can be vectors and all can be lazy
# lut(g(i))
# f(warp(i))
#class Node
#  def map( lut, options = {} )
#    
#  end
#end

# cache <-> demand/get? what about store?
# allow creation of library for pre-loading cache

# use inject for n-d clips for warp
# block(var1,var2,...) with smart subst?

# downsampling after correlation?
# ruby -Ilib -rrubygems -rmultiarray -rtest test/tc_sequence.rb
# README.rdoc, demo video

# f(g(i)) # g(i), f(g(i)) all can be vectors and all can be lazy
# lut(g(i))
# f(warp(i))
#class Node
#  def map( lut, options = {} ) # !!!
#    
#  end
#end

test type conversions

a = lazy( 16, 32 ) { |i,j| Sequence[ i, j ] } # ???
a = lazy( 8, 8 ) { |i,j| Sequence[ i, a[j] * sin( i + b[j] ) ] }.hist 8, 8
parallel { ... }

lines:
[ i, a[j] * sin( i + b[j] ) ].hist

lines:
lazy { |i,j| i.zip( a[j] * sin( i + b[j] ) ) }.histogram 32, 20

lines:
lazy { |i,j| Sequence[ i, a[j] * sin( i + b[j] ) ] }.histogram 32, 20
combined histograms?

circle:
[ sin( i ) * r, cos( i ) * r ].hist

